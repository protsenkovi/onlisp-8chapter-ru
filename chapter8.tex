\documentclass[12pt, a4paper]{article} %,twoside

\usepackage[literat, microtype, nocolor]{derradeiro}


\setcounter{secnumdepth}{0}

\begin{document}

\section{Когда использовать макросы}

Как определить должно ли данное действие быть реализовано в виде функции или в виде макроса? Чаще всего существует чёткое различие между случаями в которых лучше использовать макросы и случаями в которых они не нужны. По умолчанию мы должны использовать функции: не элегантно использовать макрос там, где можно использовать функцию. Мы должны обращаться к макросам только там, где они дают нам специфические преимущества. 

Когда же макросы дают преимущества? Это предмет обсуждения данной главы. Обычно вопрос не столько в преимуществе, сколько в необходимости. Большую часть вещей, которую мы делаем с помощью макросов невозможно сделать с помощью функций. Раздел 8.1 перечисляет виды операторов, которые могут быть реализованы только как макросы. Однако, существует небольшой (но интересный) класс пограничных случаев, где оператор справедливо может быть написан и как функция, и как макрос. Для таких ситуаций, в разделе 8.2 приводятся аргументы за и против макросов. В итоге, рассмотрев то, что можно сделать с помощью макросов, мы обратимся в разделе 8.3 к взаимосвязанному вопросу: что люди делают с помощью них?

\subsection{Когда нет выбора}

Общий принцип правильного проектирования таков, что если вы находите похожий код в нескольких местах программы вы должны написать подпрограмму и заменить похожие участки вызовом этой подпрограммы. Когда мы применяем этот принцип к Lisp программам, мы должны решить, должна ли быть <<подпрограмма>> функцией или макросом.

В некоторых случаях проще принять решение писать макрос вместо функции, так как только макрос может сделать то, что нужно. Функция похожая на \textsc{1+} потенциально могла быть написана как функция и как макрос:
\begin{lstlisting}[language=Lisp]
    (defun 1+ (x) (+ 1 x))

    (defmacro 1+ (x) `(+ 1 ,x))
\end{lstlisting}
Но \textsc{while}, из секции 7.3, может быть определена только как макрос:
\begin{lstlisting}[language=Lisp]
    (defmacro while (test &body body)
        `(do ()
             ((not ,test))
             ,@body))
\end{lstlisting}
Не существует способа повторить поведение этого макроса при помощи функции. Определение \texttt{while} вклеивает выражения переданные как \texttt{body} в \texttt{do}, где они вычисляются только если \texttt{test} выражение возвращает \texttt{nil}. Ни одна функция не может сделать этого; в вызове функции все аргументы вычисляются ещё до того как вызовется сама функция.

Когда вам понадобился макрос, что вы хотите получить от него? Макросы могут сделать две вещи, которые не могут сделать функции: они могут контролировать (или предотвратить) вычисление своих аргументов, а также они разворачиваются непосредственно в вызывающий контекст. Любое приложение, нуждающееся в макросах, в конечном счёте испытывает потребность в одном или обоих этих свойствах.

Неформальное объяснение, что <<макросы не вычисляют свои аргументы>> слегка неверно. Точнее будет сказать, что макросы \textit{контролируют} вычисление своих аргументов в вызове макроса. В зависимости от того, куда аргумент помещён в развёртке макроса, он может быть вычислен однажды, много раз или совсем никогда. Макросы производят такой контроль четырьмя способами:
\begin{enumerate}
    \item \textit{Трансформация.} Макрос \texttt{setf} один из класса макросов, которые разделяют свои аргументы на части до их вычисления. Для встроенной функции доступа всегда есть парная, задача которой  установить то, что вернула функция доступа. Обратная функция \texttt{car} это \texttt{rplaca}, \texttt{cdr} --- \texttt{rplacd} и так далее. С помощью \texttt{setf} мы можем обращаться к таким функциям доступа так, как будто они являются переменными, например \texttt{(setf (car x) 'a)}, который раскрывается в \texttt{(progn (rplaca x 'a) 'a)}.

    Чтобы осуществить такой трюк, \texttt{setf} должна заглянуть внутрь своего первого аргумента. Чтобы это узнать, что в текущем случае нужна \texttt{rplaca}, \texttt{setf} должна увидеть, что первый аргумент начинается с \texttt{car}. Таким образом \texttt{setf} и любой другой оператор, преобразующий свои аргументы, должны быть реализованы в виде макросов.

    \item \textit{Связывание.} Лексические переменные должны находиться непосредственно в коде. Первый аргумент для \texttt{setq} например не вычисляется, поэтому всё что построено на основе \texttt{setq} должно раскрываться в \texttt{setq}, нежели быть функцией, которой её вызывает. Аналогично для операторов таких как \texttt{let}, чьи аргументы присутствуют как параметры в \texttt{lambda} выражении, для макросов как \texttt{do}, раскрывающихся в \texttt{lets} и так далее. Любой новый оператор, изменяющий лексические привязки своих аргументов должн быть написан как макрос.
    \item \textit{Вычисление при определённом условии.} Все аргументы функции вычисляются. В конструкциях наподобие \texttt{when} мы хотим, чтобы часть аргументов вычислялась только при определённых условиях. Такая гибкость возможна только с помощью макросов.
    \item \textit{Многократное вычисление.} Все аргументы функций вычисляются, и вычисляются они только один раз. Нам необходим макрос для определения конструкции наподобие \texttt{do}, где нужные нам аргументы вычисляются многократно.
\end{enumerate}

Также существует несколько способов воспользоваться свойством раскрытия макроса в коде. Важно обратить внимание на то, что раскрытие таким образом появляется в лексическом контексте вызова макроса, так как два из трёх случаев использования макросов полагается на этот факт. Вот они:

\begin{enumerate} \setcounter{enumi}{4}
    \item \textit{Использование контекста вызова.} Макрос может создать раскрытие, содержащее переменную, чья привязка определяется контекстом вызова. Поведение следующего макроса:
\begin{lstlisting}[language=Lisp]
    (defmacro foo (x)
        '(+ ,x y))
\end{lstlisting}
    зависит от привязки \texttt{y} там, где вызывается \texttt{foo}.

    Такой тип лексического взаимодействия обычно рассматривается скорее как источник вреда, чем пользы. Чаще всего это будет плохим стилем написания подобного макроса. Идеал функционального программирования также применим и к макросам: предпочтительный способ общения с макросом --- через его параметры. Действительно, настолько редко требуется использовать контекст вызова, что чаще всего это происходит именно по ошибке. (Смотрите Главу 9.) Из всех макросов в этой книге, только макрос передачи продолжения (continuation) (Глава 20) и некоторые части \texttt{ATN} компилятора (Глава 23) используют вызывающее окружение таким образом. 
    \item \textit{Создание окружения-обёртки.} Макрос также может заставить свои аргументы выполняться в новом лексическом окружении. Классический пример \texttt{let}, который может быть реализован как макрос над \texttt{lambda} (страница 144). Внутри тела выражения такого как \texttt{(let ((y 2)) (+ x y))}, \texttt{y} будет ссылаться на новую переменную.

    \item \textit{Сохранение вызовов функций.} Третье последствие встраивания раскрытия макроса заключается в том, что в скомпилированном коде нет издержек на вызов макроса. К времени выполнения программы вызов макроса будет заменён его раскрытием. (Тот же принцип справедлив и для функции объявленной \texttt{inline}.)
\end{enumerate}

Особенно важно, что случаи 5 и 6, при их неумышленном использовании, создают проблему захвата переменной --- самое неприятное, чего стоит опасаться создателю макроса. Захват переменной обсуждается в главе 9.

Вместо семи способов использования макроса, правильнее было бы сказать шесть с половиной. В идеальном мире, все компиляторы Common Lisp будут следовать объявлениям \texttt{inline} и экономия на вызовах функций будет задачей встраиваемых функций, не макросов. Идеальный мир оставлен читателю в качестве упражнения. 

\section{Макрос или функция?}

Предыдущий раздел касался простых случаев. Любой оператор, которому необходим доступ к параметрам до их вычисления должен быть написан как макрос, потому что других вариантов нет. Что же насчёт тех операторов, которые могут быть написаны и тем и другим способом? К примеру возьмём оператор \texttt{avg}, который возвращает среднее от всех аргументов. Он может быть определён как функция
\begin{lstlisting}[language=Lisp]
    (defun avg (&rest args)
        (/ (apply #'+ args) (length args)))
\end{lstlisting}
но также его вполне обоснованно можно реализовать как макрос
\begin{lstlisting}[language=Lisp]
    (defmacro avg (&rest args)
        `(/ (+ args) ,(length args)))
\end{lstlisting}
потому, что версия с функцией повлечёт ненужные вызовы функции \texttt{length} при каждом вызове \texttt{avg}. Во время компиляции мы можем не знать значения аргументов, но мы знаем их количество, так что вызов \texttt{length} с тем же успехом может быть сделан на этом этапе. Ниже приведено несколько размышлений о вещах, которые нужно брать в расчёт когда мы сталкиваемся с таким выбором:
\begin{center}
    \textsc{The Pros}
\end{center}
\begin{enumerate}
    \item \textit{Вычисление на этапе компиляции}. Вызов макроса разбит на два вычисления: когда макрос раскрывается и когда раскрытие вычисляется. Все раскрытия в Lisp программе происходят при компиляции и каждый бит вычесленный во время компиляции это бит, который не будет тормозить программу во время её работы. Если оператор может быть написан так, что часть своей работы будет выполняться на этапе раскрытия макроса, тогда эффективнее реализовывать его макросом, потому, что ту работу, с которой не справился умный компилятор должна будет делать функция во время выполнения. Глава 13 описывает макросы аналогичные \texttt{avg}, которые делают часть своей работы при раскрытии.

    \item \textit{Интеграция с Lisp.} Иногда, использование макросов вместо функций делает программу более интегрированной с Lisp. Вместо написания программы для решения определённой проблемы, вы можете использовать макрос для преобразования проблемы в ту, котороую Lisp уже умеет решать. Такой подход, когда возможен, обычно сокращает код программы, и также делаёт её более эффективной: сокращает, так как Lisp делает часть работы за вас, делает эффективнее, так как промышленные Lisp системы в большинстве выжимают всё до последнего в плане эффективности по сравнению с пользовательскими программами. Это преимущество появляется чаще всего во встроенных языках, о которых пойдёт речь начиная с главы 19.
    
    \item \textit{Экономия вызовов функций}. Вызов макроса раскрывается непосредственно в код, где он встречается. Так что если вы какую-то часть кода как макрос, вы сэкономите вызов функции на каждом вызове. В ранних диалектах Lisp, программисты пользовались этим преимуществом макросов для экономии вызовов функции во время выполнения. В Common Lisp, эта работа перекладывается на функции объявленные как \texttt{inline}.

    Объявляя функцию как \texttt{inline}, вы просите компилятор скомпилировать её непосредственно в вызываемый код, также как макрос. Однако, здесь есть расхождение между теорией и практикой; \textsc{CLTL2} (стр. \pageref{229}) говорит нам <<компилятор волен игнорировать декларацию>> и некоторые Common Lisp компиляторы это и делают. Поэтому до сих пор может быть оправдано использование макросов для сокращения количества вызовов функций, если вы вынуждены использовать такой компилятор.
\end{enumerate}

В некоторых случаях комбинированное преимущество от эффективности и тесной интеграции с Lisp может дать серьёзный повод для использования макросов. В компиляторе запросов главы 19,  количество вычислений, которые можно перераспределить на этап компиляции настолько большое, что оправдывает превращение всей программы в один гигантский макрос. Сделанное для увеличения скорости, изменение также делает код теснее интегрированным с Lisp: в новой версии проще использовать Lisp выражения --- например арифметические выражения --- внутри запроса.

\begin{center}
    \textsc{The Cons}
\end{center}

\begin{enumerate} \setcounter{enumi}{3}
    \item \textit{Функции --- данные}, в то время как макросы больше похожи на инструкции компилятору. Функции могут быть переданы как аргументы (например в \texttt{apply}), возвращены другими функциями, либо сохранены в структурах. Ни что из перечисленного не возможно сделать макросами. 

    В некоторых случаях, вы можете достичь того, что хотите обернув вызов макроса ламбда функцией. Это работает, например, если вы хотите вызвать \texttt{apply} или \texttt{funcall} над конкретным макросом:
\begin{lstlisting}[language=Lisp]
    > (funcall #'(lambda (x y) (avg x y)) 1 3)
    2
\end{lstlisting}
    Однако, это неудобно. К тому же это не всегда сработает: даже если также как \texttt{avg}, макрос имеет \texttt{\&rest} параметр, не существует способа передать изменяемое количество аргументов.

    \item \textit{Ясность исходного кода}. Макро объявления могут быть тяжелее в чтении, чем эквивалентные объявления функций. Так что если написание чего-то как макрос сделает программу незначительно лучше, лучше использовать функцию.

    \item \textit{Ясность во время выполнения}. Макросы иногда труднее отлаживать чем функции. Если вы ловите ошибку времени выполнения в коде, содержащем большое количество вызовов макросов, код, который вы видете в backtrace, может состоять из раскрытий всех этих макросов, и быть мало похожим на исходный код который вы написали.

    И по той же причине, что макросы исчезают после раскрытия, их вызовы нельзя учесть. Обычно вы не можете использовать \texttt{trace}, чтобы увидеть как вызывался макрос. Если даже это сработало, \texttt{trace} покажет вызов функции раскрытия макроса, но не сам вызов макроса.

    \item \textit{Рекурсия}. Использование рекурсии в макросах не такое простое как в функциях. Несмотря на то, что функция раскрытия макроса может быть рекурсивной, само раскрытие таковым быть не может. Раздел 10.4 касается вопроса рекурсии в макросах.
\end{enumerate}

Все эти рассуждения должны быть сбалансированы относительно друг друга при решении о использовании макросов. Только опыт может подсказать, какое из них будет доминирующим. Однако, примеры макросов, появляющиеся в последующих главах покрывают большую часть ситуаций в которых макросы полезны. Если проектируемый макрос аналогичен одному из приведённых здесь, тогда в большой вероятностью реализовывать его будет безопасно.

В заключении, нужно отметить, что ясность (пункт 6) редко становится проблемой. Отладка кода, использующего большое количество макросов будет не такой сложной как может показаться. Если объявления макросов занимают несколько сотен строк, то их было бы неприятно отлаживать во время выполнения. Но утилиты, в конечном счёте, стремятся к написанию небольших, надёжных слоев. В общем случае их объявления занимают не больше 15 строк. Так что даже на случай сосредоточенного обдумывания логов обратной трассировки, таки макросы не сильно затуманят ваш взгляд.


\subsection{Применения макросов}

Зная возможности макросов следующий вопрос, который требует ответа, это: в каком типе приложений мы можем их использовать? Наиболее общий ответом использования макросов можно считать их применение для синтаксических преобразований. Это не наводит на мысль что область применения макросов ограничена. Так как Lisp программы составлены из списков\footnote{В смысле являются входными данными для компилятора. Функции более не представляют из себя списки, как было в ранних диалектах. }, которые есть Lisp структуры данных, <<синтаксическое преобразование>> может означать по истине большие возможности. В главах 19-24 представлены программы, чья задача может быть описана как синтаксическое преобразование и которые в сущности все являются макросами.

Область применения макросов занимает всё пространство между небольшими макросами общего назначения, таких как \texttt{while} и большими, специализированными под задачу макросами, которые приведены в последующих главах. С одной стороны находятся \textit{утилиты}, макросы напоминающие те, которые встроены в каждый Lisp. Они обыкновенно небольшие, наиболее общие и написаны вне какого-либо контекста. Однако, вы можете писать утилиты и для специфического класса программ, когда например у вас есть коллекция макросов для использования в графической программе, они становятся очень похожими на язык для графики. С другой стороны, макросы помогают вам писать целые программы на языке, отличном от Lisp. Макросы используемые таким образом называются реализацией \textit{встроенного языка} (embedded languages).

Утилиты --- первый результат стиля разработки снизу-вверх. Даже если программа слишком мала для построения из слоёв, она всё же может получить преимущество от добавления нижнего слоя, самого Lisp. Утилита \texttt{nil!}, устанавливающая аргумент в \texttt{nil}, не может быть по-другому реализована, кроме как макросом:
\begin{lstlisting}[language=Lisp]
    (defmacro nil! (x)
        `(setf ,x nil))
\end{lstlisting}
Посмотрев на \texttt{nil!}, у кто-нибудь может захочет сказать, что он вообще то ничего не делает, кроме сокращения времени набора. Это правда, но всё что делают макросы в действительности сокращение наборы машинного языка. Значение утилит не должно быть недооценено, потому что эффект кумулятивный: несколько слоёв специальных макросов могут стать различием между элегантной программой и некуда негодной.

Большинство утилит --- это материализованные шаблоны. Когда вы замечает шаблон в своём коде, подумайте над превращением его в утилиту. Шаблоны --- это как раз то, в чём компьютеры очень хороши. Зачем вы должны утруждать себя их повторять, когда вы можете заставить делать это программу? Представьте, что при написании некоторой программы вы обнаруживаете за собой, что во многих местах используете \texttt{do} циклы одинакового вида:
\begin{lstlisting}[language=Lisp]
    (do ()
        ((not <condition>))
        . <body of code>)
\end{lstlisting}
Когда вы видите повторяющийся шаблон в коде, у него обычно есть имя. Имя этого шаблона --- \texttt{while}. Если мы хотим сделать из него новую утилиту, мы должны будем использовать макрос, так как нам необходимо вычисление по условию и повторяющееся вычисление. Если мы определим \texttt{while} используя определения со страницы \pageref{91}:
\begin{lstlisting}[language=Lisp]
    (defmacro while (test &body body)
      `(do ()
           ((not ,test))
           ,@body))
\end{lstlisting}
тогда мы можем переписать все шаблоны как:
\begin{lstlisting}[language=Lisp]
    (while <condition>
        . <body of code>)
\end{lstlisting}
Сделав это мы получим более лаконичный код, точнее описывающий то, что он делает.

Возможность преобразовывать аргументы делает макросы полезными для написания интерфейсов. Подходящий макрос позволит набирать более короткие выражения, там где потребовалось бы объёмное. Хотя графические интерфейсы снижают необходимость писать таковые для конечных пользователей, программисты используют такой тип макросов постоянно. Самый простой пример --- \texttt{defun}, который делает привязку функций по виду похожей на описание функций в таких языках как Pascal и С. В главе 2 упомянуты следующие два выражения, имеющий одинаковый эффект:
\begin{lstlisting}[language=Lisp]
    (defun foo (x) (* x 2))

    (setf (symbol-function 'foo)
          #'(lambda (x) (* x 2)))
\end{lstlisting}
Так что \texttt{defun} может быть реализован как макрос, превращающий первое в последнее. Мы можем представить, что он написан следующим образом:
\begin{lstlisting}[language=Lisp]
    (defmacro our-defun (name parms &body body)
      `(progn 
         (setf (symbol-function ',name)
               #'(lambda ,parms (block , name ,@body)))
          ',name))
\end{lstlisting}
Макросы такие как \texttt{while} и \texttt{nil!} можно описать как утилиты общего назначения. Любая Lisp программы может их использовать. Но конкретные области как правило могут иметь свои утилиты. Нет причин предполагать, что Lisp база единственный уровень на котором вы можете расширять язык программирования. Если вы пишете например \textsc{cad} программу, лучших результатов можно достичь при написании в два слоя: язык (либо если вы предпочитаете более скромный термин, набор инструментов) для \textsc{cad} программ и вышестоящий слой --- ваша программа. 
\begin{figure}[h]
\begin{lstlisting}[language=Lisp]
    (defun move-objs (objs dx dy)
      (multiple-value-bind (x0 y0 x1 y1) (bounds objs)
        (dolist (o objs)
          (incf (obj-x o) dx)
          (incf (obj-y o) dy))
        (multiple-value-bind (xa ya xb yb) (bounds objs)
          (redraw (min x0 xa) (min y0 ya)
                  (max x1 xb) (max y1 yb)))))

    (defun scale-objs (objs dx dy)
      (multiple-value-bind (x0 y0 x1 y1) (bounds objs)
          (dolist (o objs)
            (setf (obj-dx o) (* (obj-x o) factor)
                  (obj-dy o) (* (obj-y o) factor)))
          (multiple-value-bind (xa ya xb yb) (bounds objs)
            (redraw (min x0 xa) (min y0 ya)
                    (max x1 xb) (max y1 yb)))))
\end{lstlisting}
\caption{Исходные \texttt{move} и \texttt{scale}}
\label{fig:8-orig-move-scale}
\end{figure}

Lisp размывает границы, которые в других языках воспринимаются как должные. В других языках, существуют концептуальные различия между временем компиляции и работой программы, программой и данными, языком и программой. В Lisp, эти ограничения существуют только как устные соглашения. Не существует разделяющей линии, например, между языком и программой. Вы можете провести линию так, чтобы это соответствовало поставленной задаче. Так что это не более чем вопрос терминологии называть ли подложенный слой кода инструментарием или языком. Одно из удобств считать его языком в том, что это подсказывает вам, что его можно расширять так же как вы расширяете Lisp утилитами.

Возьмём к примеру интерактивную графическую программу для редактирования изображений. Для простоты, мы предположим, что единственные объекты, с которыми имеет дело программа --- линии, представленные начальной точкой \texttt{<x, y>} и вектором \texttt{<dx, dy>}. Одной из возможностей, которая такая программа должна будет обладать, это перемещение группы объектов. Это задача функции \texttt{move-objs} (Рисунок. \ref{fig:8-orig-move-scale}). Для эффективности, мы не хотим перерисовывать весь экран после каждой операции, только те части, которые изменились. Следовательно два вызова функции \texttt{bounds}, которая возвращает четыре координаты \texttt{(min x, min y, max x, max y)} представляющие прямоугольник в котором находятся объекты. Часть отвечающая за операцию заключена между двумя вызовами \texttt{bounds}, посредством которых находятся прямоугольные области до смещения и после, и затем перерисовывается затронутая часть изображения. 

Функция \texttt{scale-objs} предназначена для изменения размеров группы объектов. В виду того, что изменяемая часть может увеличиться или сжаться в зависимости от масштабного коэффициента, эта функция также должна производить все операции между двумя вызовами \texttt{bounds}. По мере того как мы будем писать подобные программы, мы увидим больше случаев появления этого шаблона: в функциях поворота, отображения, транспонирования и так далее.
\begin{figure}[h]
\begin{lstlisting}[language=Lisp]
    (defmacro with-redraw ((var objs) &body body)
      (let ((gob (gensym))
            (x0 (gensym)) (y0 (gensym))
            (x1 (gensym)) (y1 (gensym)))
        `(let ((,gob ,objs))
           (multiple-value-bind (,x0 ,y0 ,x1 ,y1) 
                                (bounds ,gob)
              (dolist (,var ,gob) ,@body)
              (multiple-value-bind (xa ya xb yb) 
                                   (bounds ,gob)
                  (redraw (min ,x0 xa) (min ,y0 ya)
                          (max ,x1 xb) (max ,y1 yb)))))))

    (defun move-objs (objs dx dy)
        (with-redraw (o objs)
            (incf (obj-x o) dx)
            (incf (obj-y o) dy)))

    (defun scale-objs (objs dx dy)
        (with-redraw (o objs)
            (setf (obj-dx o) (* (obj-x o) factor)
                  (obj-dy o) (* (obj-y o) factor))))
\end{lstlisting}
\caption{Исходные \texttt{move} и \texttt{scale}}
\label{fig:8-filleted-move-scale}
\end{figure}
\clearpage\newpage
С макросом мы можем абстрагировать подобный код таких функций. Макрос \texttt{with-draw} на рисунке \ref{fig:8-filleted-move-scale} является единым каркасом, используемым в функциях. Как результат, они могут быть написаны в четыре строки, как в конце рисунка \ref{fig:8-filleted-move-scale}. Уже на этих двух функциях новый макрос показал свою лаконичность. И на сколько более ясные стали две функции после абстрагирования деталей отрисовки.

С одной стороны можно рассматривать \texttt{with-redraw} как конструкцию языка для написания интерактивных графических программ. После того как мы разработает больше подобных макросов, они в действительности начнут быть похожими на язык программирования, а сама наша программа станет более  элегантной, и можно подумать, что она была написана на специально созданном для неё языке.

Другим вариантом использования макросов является реализация встроенных языков. Lisp особенно хорош для написания языков программирования, так как Lisp программы могут быть выражены в виде списков, и Lisp обладает встроенным парсером (\texttt{read}) и компилятором (\texttt{compile}) для такого представления. Чаще даже вам не понадобится вызывать \texttt{compile}; вы можете иметь свой встроенный язык, компилируемый неявно, компилированием кода совершающего преобразования (стр. 25).

Встроенный язык этот такой язык, который не написан поверх Lisp, а смешан с ним, так что синтаксис --- это смесь из Lisp и конструкций специфического языка. Наивным способом создать такой язык является написание для него интерпретатора (на Lisp). Более хорошим способом, если это возможно, являются преобразования языка: преобразовать каждое выражение в Lisp код, который затем интерпретатор считает и выполнит. Та задача в которой макросы выходят на сцену. Работа макросов в точности работа по преобразованию одного типа выражений в другие, так что они становятся естественным выбором для написания встроенных языков. 

В общем случае, чем большая часть встроенного языка может быть реализована с помощью макросов, тем лучше. Во-первых, это уменьшение работы. Если в новом языке есть арифметика, например, вы не сталкиваетесь со сложностями представления и манипулирования числовыми значениями. Если возможности Lisp достаточно для ваших целей, тогда вы можете просто преобразовать ваши арифметические выражения в эквивалентные выражения на Lisp, всё остальное за вас сделает Lisp.

Использование преобразований также как правило сделает ваш встроенные язык быстрее. Интерпретаторы обладают неудобствами связанными с скоростными характеристиками. Например, если код встречается в цикле, то интерпретатор будет совершать работу на каждой итерации, в отличие от скомпилированного когда, в котором она сделана единожды. Встроенный язык имеющий свой интерпретатор в любом случае будет медленным, даже если он сам скомпилирован. Но если выражения нового языка преобразованы в Lisp, тогда окончательный код будет скомпилирован Lisp компилятором. Язык реализованный таким образом не будет иметь издержек интерпретации. Сократив время на написание компилятора для вашего языка, макросы оставят преимущество быстрого выполнения. В действительности, макросы преобразующие новый язык могу рассматриваться как компилятор для него, использующий для основной части работы компилятор Lisp.

Мы не будем касаться никаких примеров встроенного языка, в виду того, что главы 19-25 полностью посвящены этой теме. Глава 19 связана с темой разницы между интерпретацией и преобразованием встроенного языка, приводит один и тот же язык реализованный двумя способами.

В одной из книг по Common Lisp утверждается, что область применения макросов ограничена, доказывая это тем фактом, что из всех операторов, определённых в \textsc{cltl1}, меньше 10\% занимают макросы. Говорить так, значит то же, что если наш дом сделан из кирпичей, то наша мебель также должна быть из них сделана.  Пропорция макросов в Common Lisp программе будет полностью зависеть от её назначения. Некоторые программы не будет содержать макросов. Некоторые программы будут полностью состоять из них.


\end{document}
